import { ComplexityNotation } from '@/modules/Algorithm/types/types'

type AlgorithmInfoComplexity = Omit<ComplexityNotation, 'time'>

interface AlgorithmInfo {
  complexity: {
    bigOCase: AlgorithmInfoComplexity
    omegaCase: AlgorithmInfoComplexity
    thetaCase: AlgorithmInfoComplexity
  }
  description: string
  title: string
}

interface AlgorithmsInfo {
  searching: {
    binarySearching: AlgorithmInfo
    linearSearching: AlgorithmInfo
  }
  sorting: {
    arrayPrototypeSorting: AlgorithmInfo
    bubbleSorting: AlgorithmInfo
    insertionSorting: AlgorithmInfo
    quickSorting: AlgorithmInfo
    selectionSorting: AlgorithmInfo
  }
}

export const ALGORITHMS_INFO: AlgorithmsInfo = {
  sorting: {
    bubbleSorting: {
      title: 'Сортировка пузырьком',
      description:
        'Наиболее эффективен на уже отсортированных или почти отсортированных массивах, но его производительность значительно снижается на больших наборах данных с хаотическим расположением элементов.',
      complexity: {
        bigOCase: {
          notation: 'n^2',
          description:
            'Происходит, когда массив отсортирован в обратном порядке. Алгоритм должен выполнить n-1 проходов, каждый из которых включает n-i сравнений, что приводит к квадратичной временной сложности.',
        },
        omegaCase: {
          notation: 'n',
          description:
            'Лучший случай происходит, когда массив уже отсортирован. В этом случае алгоритм завершится после одного прохода, обнаружив, что обменов не требуется.',
        },
        thetaCase: {
          notation: 'n^2',
          description: 'В среднем случае также требуется выполнение n-1 проходов с примерно n/2 сравнениями за проход.',
        },
      },
    },
    selectionSorting: {
      title: 'Сортировка выбором',
      description:
        'Сортировка выбором может быть полезна для небольших массивов или когда важна простота реализации, а не эффективность. Она также эффективна, когда минимизация количества обменов важнее минимизации времени выполнения.',
      complexity: {
        bigOCase: {
          notation: 'n^2',
          description:
            'Происходит, когда массив отсортирован в обратном порядке или в случайном порядке. Алгоритм должен выполнить n-1 проходов, каждый из которых включает n-i-1 сравнений.',
        },
        thetaCase: {
          notation: 'n^2',
          description: 'В среднем случае также требуется выполнение n-1 проходов с примерно n/2 сравнениями за проход.',
        },
        omegaCase: {
          notation: 'n^2',
          description:
            'Даже в лучшем случае сортировка выбором требует n-1 проходов и n-i-1 сравнений на каждом проходе, что приводит к квадратичной временной сложности.',
        },
      },
    },
    insertionSorting: {
      title: 'Сортировка вставками',
      description:
        'Сортировка вставками особенно эффективна для небольших массивов и массивов, которые уже частично отсортированы. Алгоритм стабилен и может использоваться в онлайн-сортировке, где элементы поступают постепенно.',
      complexity: {
        bigOCase: {
          notation: 'n^2',
          description:
            'Происходит, когда массив отсортирован в обратном порядке. В этом случае каждый элемент должен быть перемещен на свое место, что требует выполнения примерно n^2/2 сравнений и перемещений.',
        },
        thetaCase: {
          notation: 'n^2',
          description:
            'В среднем случае также требуется выполнение примерно n^2/4 сравнений и перемещений, так как элементы вставляются в случайные позиции.',
        },
        omegaCase: {
          notation: 'n^2',
          description:
            'Лучший случай происходит, когда массив уже отсортирован. Алгоритм просто проходит по массиву и выполняет n-1 сравнений и 0 перемещений, так как каждый элемент уже находится на своем месте.',
        },
      },
    },
    quickSorting: {
      title: 'Быстрая сортировка',
      description:
        'Быстрая сортировка использует подход "разделяй и властвуй" для рекурсивного деления массива на меньшие подмассивы, она эффективна для сортировки больших массивов и является одним из самых быстрых алгоритмов в среднем. Она также хорошо работает с массивами, которые размещены в случайном порядке.',
      complexity: {
        bigOCase: {
          notation: 'n^2',
          description:
            'Худший случай происходит, когда в качестве опорного элемента (pivot) всегда выбирается наименьший или наибольший элемент. В этом случае массив делится неравномерно, что приводит к квадратичной временной сложности. Однако на практике худший случай можно избежать с помощью различных стратегий выбора опорного элемента, таких как случайный выбор или медиана трех.',
        },
        thetaCase: {
          notation: 'n*log*n',
          description:
            'В среднем случае алгоритм делит массив на две примерно равные части, что приводит к логарифмической глубине рекурсии и линейному количеству операций на каждом уровне рекурсии. Это обеспечивает среднюю временную сложность Θ(n log n).',
        },
        omegaCase: {
          notation: 'n*log*n',
          description:
            'Лучший случай происходит, когда массив делится на две примерно равные части на каждом шаге, что приводит к логарифмической глубине рекурсии и линейному количеству операций на каждом уровне рекурсии. Это обеспечивает временную сложность Ω(n log n).',
        },
      },
    },
    arrayPrototypeSorting: {
      title: 'Array.prototype.sort()',
      description:
        'Метод sort эффективен для общего использования в JavaScript, так как он встроен и оптимизирован для различных случаев использования. Он хорошо работает для сортировки небольших и средних массивов и позволяет легко сортировать массивы с пользовательской логикой сравнения. Производительность метода Array.prototype.sort зависит от реализации JavaScript движка (например, V8 в Chrome и Node.js, SpiderMonkey в Firefox). Обычно для сортировки используется алгоритм Тима Петерса (Timsort), который сочетает подходы сортировки вставками и слиянием.',
      complexity: {
        bigOCase: {
          notation: 'n*log*n',
          description:
            'Timsort, используемый в большинстве современных движков JavaScript, имеет временную сложность O(n log n) в худшем случае. Это достигается благодаря комбинации сортировки вставками и слиянием, что обеспечивает стабильную производительность.',
        },
        thetaCase: {
          notation: 'n*log*n',
          description:
            'В среднем случае производительность также составляет Θ(n log n), так как Timsort эффективно обрабатывает большинство массивов, обеспечивая быструю сортировку.',
        },
        omegaCase: {
          notation: 'n',
          description:
            'В лучшем случае, если массив уже отсортирован или почти отсортирован, Timsort может достичь линейной временной сложности Ω(n) благодаря использованию сортировки вставками для небольших подмассивов.',
        },
      },
    },
  },
  searching: {
    linearSearching: {
      title: 'Линейный поиск',
      description:
        'Линейный поиск эффективен для небольших массивов или списков, где дополнительные расходы на более сложные алгоритмы поиска не оправданы. Он также используется, когда данные не отсортированы, поскольку алгоритмы с лучшей временной сложностью, такие как бинарный поиск, требуют отсортированных данных.',
      complexity: {
        bigOCase: {
          notation: 'n',
          description:
            'Худший случай происходит, когда искомый элемент находится в конце списка или его вообще нет. В этом случае алгоритму приходится проверять все n элементов.',
        },
        thetaCase: {
          notation: 'n',
          description:
            'В среднем случае алгоритм также выполняет n/2 сравнений, что приводит к временной сложности Θ(n).',
        },
        omegaCase: {
          notation: '1',
          description:
            'Лучший случай происходит, когда искомый элемент находится в самом начале списка. В этом случае алгоритм завершает работу после одного сравнения, обеспечивая временную сложность Ω(1).',
        },
      },
    },
    binarySearching: {
      title: 'Бинарный поиск',
      description:
        'Бинарный поиск наиболее эффективен для поиска элементов в больших отсортированных массивах. Он значительно быстрее линейного поиска, особенно для больших наборов данных, так как количество проверяемых элементов уменьшается вдвое на каждом шаге.',
      complexity: {
        bigOCase: {
          notation: 'log*n',
          description:
            'Худший случай происходит, когда необходимо выполнить максимальное количество делений, что соответствует глубине бинарного дерева, равной log2(n), где n - количество элементов в массиве.',
        },
        thetaCase: {
          notation: 'log*n',
          description:
            'В среднем случае алгоритм также выполняет log2(n) сравнений, так как каждое сравнение уменьшает количество рассматриваемых элементов вдвое.',
        },
        omegaCase: {
          notation: '1',
          description:
            'Лучший случай происходит, когда искомый элемент находится в середине массива на первом шаге. В этом случае алгоритм завершает работу после одного сравнения, обеспечивая временную сложность Ω(1).',
        },
      },
    },
  },
}
